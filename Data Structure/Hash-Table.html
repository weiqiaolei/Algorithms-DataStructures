<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
    <img src="https://cdn-images-1.medium.com/max/600/1*wHiuDrmhLsyJbgGWCEBBcQ.png" />;
    <script>
        //In computing, a hash table (hash map) is a data structure which implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.

        //https://codeburst.io/objects-and-hash-tables-in-javascript-a472ad1940d9
        //We may implement a hash table, a particular data structure which utilizes javascript objects to create a numerically indexed structure to store key-value pairs (known as tuples). I’ll say that again: hash tables store key-value pairs an numerical indices generated by running the key through a hashing function.

        //The hashing function is the part of the program which takes a key and converts it to a number which will be the index at which to store it. Visualize a box, into which you empty a container of tuples, or key-value pairs. Output is an array storing the key-value pair at a numeric index. The manner by which the index is assigned varies contingent on the hash function’s implementation. Not all hashing functions are equal, some are better at creating an even distribution of key-value pairs. If every tuple is placed in the same index, then the time complexity will be comparable to that of a plain array, linear.


        //----------Hastable Initialization----------\\
        var HashTable = function (limit = 8) {
            this._limit = limit;
            this._storage = [];
            this._count = 0;
        }
        //this._storage = [/*container*/[/*bucket*/], [[/*tuple*/], []]]



        //----------Hashing Function----------\\
        String.prototype.hashCode = function (max) {
            var hash = 0;
            if (!this.length) return hash;
            for (i = 0; i < this.length; i++) {
                char = this.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(max ? hash % max : hash);
        };



        //The second part of hash table implementation is the logic dedicated to handling collisions, or the instances in which there are multiple values at a particular index, called the bucket. This is accomplished by looping through all tuples in the hash table’s index of interest to find the desired tuple.

         //----------Hashtable Insert Value----------\\
        HashTable.prototype.add = function (key, value) {
            var index = key.hashCode();
            var tuple = [key, value];
            var bucket = this._storage.get(index);
            if (bucket) {
                for (var i = 0; i < bucket.length; i++) {
                    if (bucket[i][0] === key) {
                        bucket[i][1] = value;
                    } else {
                        bucket.push(tuple);
                    }
                }
            } else {
                this._storage.set(index, [tuple]);
            }
        };

        //There is a great deal of confusion regarding the comparison between objects and hash tables. This is much like an attempted comparison between apples and granny smith apples, one is a subset of the other with particular qualities. The advantages offered by hash tables include its ability to handle cases in which a key corresponds with a native object attribute and provides constant time lookup. Below is a retrieve method added to the prototype of our HashTable class with a constant lookup time on average:

        //----------Retrieve Hashtable value---------\\
        HashTable.prototype.retrieve = function (key) {
            var index = key.hashCode();
            var bucket = this._storage.get(index);
            for (var i = 0; i < bucket.length; i++) {
                if (bucket[i][0] === key) {
                    return bucket[i][1];
                }
            }
        };

        //It is hugely important as developers to understand what is happening in the black boxes used in our code in order to grow and implement ideas in new and creative ways. However, there is a data structure, bare objects, which offers the same advantages as a hash table in javascript without the tedious need for its complicated implementation. The workaround for this is to instantiate an object without any fall through context using the bare objects, introduced in ES5. In essence, the create method on the Object prototype allows for instantiation of a new object with the delegation chain specified. It follows that passing in null will instantiate an object with no native attributes. Read more about bare objects here.

        //There is an active debate in regards to whether javascript objects are all implemented as hash tables under the hood. The good news is, you don’t have to worry about that! Javascript abstracts unnecessary details in the pursuit of allowing design of more complex systems.
    </script>

</body>
</html>